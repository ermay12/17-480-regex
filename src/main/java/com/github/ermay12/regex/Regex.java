/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.github.ermay12.regex;

import java.util.*;
import java.util.regex.Pattern;

/**
 * Regex represents a factory like class for RegularExpression construction.
 */
public class Regex {


  /*
   **************
   * Characters *
   **************
   */


  private static final List<Character> metacharacters = Arrays.asList('?', '\\', '-', '=', '[', ']', '(', ')',
      '{', '}', '<', '>', '!', '*', '.', '+',
      '^', '$', '|');


  /**
   * Returns the given character as a string, escaped if necessary
   *
   * @param c The character to sanitize
   * @return the given character as a string, escaped if necessary
   */
  static String sanitized(char c) {
    StringBuilder b = new StringBuilder();
    if (metacharacters.contains(c)) {
      b.append('\\');
    }
    b.append(c);

    return b.toString();
  }

  /**
   * Returns the given string, escaping any metacharacters that appear
   *
   * @param s the string to sanitize
   * @return the given string, escaped if necessary
   */
  static String sanitized(String s) {
    //TODO(astanesc): Use a regex or .contains?
    StringBuilder b = new StringBuilder();
    for (char c : s.toCharArray()) {
      b.append(sanitized(c));
    }
    return b.toString();
  }


  /**
   * Returns a regex that matches a single character
   *
   * @param c the character class
   * @return a regex that matches a single character
   */
  public static RegularExpression single(char c) {
    return new RegularExpression(sanitized(c));
  }

  /**
   * Returns a regex that matches a given string exactly. The given string has any special regex characters
   * escaped automatically.
   *
   * @param s the string to match against
   * @return a regex that matches the given string
   */
  public static RegularExpression string(String s) {
    return new RegularExpression(sanitized(s));
  }

  /**
   * Constructs a regular expression from the given raw regular expression. This Regular expression
   * should conform to the Java Regex language. See {@link Pattern}
   *
   * @param regex the sub-components of the regular expression
   * @return a new regular expression matching the given regex
   */
  public static RegularExpression fromRawRegex(String regex) {
    return new RegularExpression(regex);
  }
  /*
   *********************
   * Character Classes *
   *********************
   */

  /**
   * Returns a regex that matches a single character within a given character class
   *
   * @param c the character class
   * @return a regex that matches a single character within a given character class
   */
  public static RegularExpression single(CharacterClass c) {
    return c;
  }


  /*
   **************
   * Boundaries *
   **************
   */

  /**
   * The start of a line. If multi-line mode is off, then this matches the start of input
   */
  public static final RegularExpression LINE_START = new RegularExpression("^");

  /**
   * The end of a line. If multi-line mode is off, then this matches the end of input
   */
  public static final RegularExpression LINE_END = new RegularExpression("$");

  /*
   ***************
   * Quantifiers *
   ***************
   */

  /**
   * Returns a regex which matches any string that consists of the given string either once or not at all
   *
   * @param s the string to compose on
   * @return a regex which matches any string that consists of the given string repeated at most once
   */
  public static RegularExpression optional(String s) {
    return optional(s, EvaluationMethod.GREEDILY);
  }

  /**
   * Returns a regex which matches any string that consists of any string the given regex matches repeated either once or not at all
   *
   * @param r the regex to compose on
   * @return a regex which matches any string that consists of any string the given regex matches repeated either once or not at all
   */
  public static RegularExpression optional(RegularExpression r) {
    return optional(r, EvaluationMethod.GREEDILY);
  }

  /**
   * Returns a regex which matches any string that consists of the given string either once or not at all
   * This uses the provide Evaluation method
   *
   * @param s the string to compose on
   * @param t the evaluation type
   * @return a regex which matches any string that consists of the given string repeated at most once
   */
  public static RegularExpression optional(String s, EvaluationMethod t) {
    if (s.length() == 1) {
      return new RegularExpression(sanitized(s.charAt(0)), "?", t.toRegex());
    } else {
      return new RegularExpression("(?:", sanitized(s), ")?", t.toRegex());
    }
  }

  /**
   * Returns a regex which matches any string that consists of any string the given regex matches repeated either once or not at all.
   * This uses the provide Evaluation method
   *
   * @param r the regex to compose on
   * @param t the evaluation type
   * @return a regex which matches any string that consists of any string the given regex matches repeated either once or not at all
   */
  public static RegularExpression optional(RegularExpression r, EvaluationMethod t) {
    return new RegularExpression(r, r.selfAsGrouped(), "?", t.toRegex());
  }

  /**
   * Returns a regex which matches any string that consists of the given string repeated any number of times.
   *
   * @param s the string to compose on
   * @return a regex which matches any string that consists of the given string repeated any number of times.
   */
  public static RegularExpression anyAmount(String s) {
    return anyAmount(s, EvaluationMethod.GREEDILY);
  }

  /**
   * Returns a regex which matches any string that consists of the given regex repeated any number of times.
   *
   * @param r the regex to compose on
   * @return a regex which matches any string that consists of the given regex repeated any number of times.
   */
  public static RegularExpression anyAmount(RegularExpression r) {
    return anyAmount(r, EvaluationMethod.GREEDILY);
  }

  /**
   * Returns a regex which matches any string that consists of the given string repeated any number of times.
   * This uses the provide Evaluation method
   *
   * @param s the string to compose on
   * @param t the evaluation type
   * @return a regex which matches any string that consists of the given string repeated any number of times.
   */
  public static RegularExpression anyAmount(String s, EvaluationMethod t) {
    if (s.length() == 1) {
      return new RegularExpression(sanitized(s.charAt(0)), "*", t.toRegex());
    } else {
      return new RegularExpression("(?:", sanitized(s), ")*", t.toRegex());
    }
  }

  /**
   * Returns a regex which matches any string that consists of the given regex repeated any number of times.
   * This uses the provide Evaluation method
   *
   * @param r the regex to compose on
   * @param t the evaluation type
   * @return a regex which matches any string that consists of the given regex repeated any number of times.
   */
  public static RegularExpression anyAmount(RegularExpression r, EvaluationMethod t) {
    return new RegularExpression(r, r.selfAsGrouped(), "*", t.toRegex());
  }

  /**
   * Returns a regex which matches any string that consists of the given character repeated at least once.
   *
   * @param c the character to compose on
   * @return a regex which matches any string that consists of the given character repeated at least once.
   */
  public static RegularExpression atLeastOne(char c) {
    return atLeastOne(c, EvaluationMethod.GREEDILY);
  }

  /**
   * Returns a regex which matches any string that consists of any string the given regex matches repeated at least once.
   *
   * @param r the regex to compose on
   * @return a regex which matches any string that consists of any string the given regex matches repeated at least once.
   */
  public static RegularExpression atLeastOne(RegularExpression r) {
    return atLeastOne(r, EvaluationMethod.GREEDILY);
  }

  /**
   * Returns a regex which matches any string that consists of the given character repeated at least once.
   *
   * @param c the character to compose on
   * @param t the evaluation type
   * @return a regex which matches any string that consists of the given character repeated at least once.
   */
  public static RegularExpression atLeastOne(char c, EvaluationMethod t) {
    return new RegularExpression(sanitized(c), "+", t.toRegex());
  }

  /**
   * Returns a regex which matches any string that consists of any string the given regex matches repeated at least once.
   * This uses the provide Evaluation method
   *
   * @param r the regex to compose on
   * @param t the evaluation type
   * @return a regex which matches any string that consists of any string the given regex matches repeated at least once.
   */
  public static RegularExpression atLeastOne(RegularExpression r, EvaluationMethod t) {
    return new RegularExpression(r, r.selfAsGrouped(), "+", t.toRegex());
  }

  /**
   * Returns a regex which matches any string that consists of the given string repeated between min and max times
   *
   * @param s   the string to repeat
   * @param min the minimum number of times the character should repeat (inclusive)
   * @param max the maximum number of times the character should repeat (inclusive)
   * @return a regex which matches any string that consists of the given string repeated between min and max times
   */
  public static RegularExpression repeat(String s, int min, int max) {
    return repeat(s, min, max, EvaluationMethod.GREEDILY);
  }

  /**
   * Returns a regex which matches any string that consists of any string the given regex matches repeated between min and max times
   *
   * @param g   the regex to repeat
   * @param min the minimum number of times the regex should repeat (inclusive)
   * @param max the maximum number of times the regex should repeat (inclusive)
   * @return a regex which matches any string that consists of any string the given regex matches repeated between min and max times
   */
  public static RegularExpression repeat(RegularExpression g, int min, int max) {
    return repeat(g, min, max, EvaluationMethod.GREEDILY);
  }

  /**
   * Returns a regex which matches any string that consists of the given string repeated between min and max times
   * This uses the provide Evaluation method
   *
   * @param s   the string to repeat
   * @param min the minimum number of times the character should repeat (inclusive)
   * @param max the maximum number of times the character should repeat (inclusive)
   * @param t   the evaluation type
   * @return a regex which matches any string that consists of the given string repeated between min and max times
   */
  public static RegularExpression repeat(String s, int min, int max, EvaluationMethod t) {
    if (s.length() == 1) {
      return new RegularExpression(sanitized(s.charAt(0)),
          "{", Integer.toString(min), ",",
          Integer.toString(max), "}", t.toRegex());
    } else {
      return new RegularExpression(
          "(?:", sanitized(s), ")",
          "{", Integer.toString(min), ",",
          Integer.toString(max), "}", t.toRegex());
    }
  }

  /**
   * Returns a regex which matches any string that consists of any string the given regex matches repeated between min and max times
   * This uses the provide Evaluation method
   *
   * @param g   the regex to repeat
   * @param min the minimum number of times the regex should repeat (inclusive)
   * @param max the maximum number of times the regex should repeat (inclusive)
   * @param t   the evaluation type
   * @return a regex which matches any string that consists of any string the given regex matches repeated between min and max times
   */
  public static RegularExpression repeat(RegularExpression g, int min, int max, EvaluationMethod t) {
    return new RegularExpression(g, g.selfAsGrouped(),
        "{", Integer.toString(min), ",",
        Integer.toString(max), "}", t.toRegex());
  }

  /**
   * Returns a regex which matches any string that consists of the given string repeated exactly amount times
   *
   * @param s      the string to repeat
   * @param amount the number of times the regex should repeat
   * @return a regex which matches any string that consists of the given string repeated exactly amount times
   */
  public static RegularExpression repeatExactly(String s, int amount) {
    if (s.length() == 1) {
      return new RegularExpression(sanitized(s.charAt(0)),
          "{", Integer.toString(amount), "}");
    } else {
      return new RegularExpression(
          "(?:", sanitized(s), ")",
          "{", Integer.toString(amount), "}");
    }
  }

  /**
   * Returns a regex which matches any string that consists of any string the given regex matches repeated exactly amount times
   *
   * @param g      the regex to repeat
   * @param amount the number of times the regex should repeat
   * @return a regex which matches any string that consists of any string the given regex matches repeated exactly amount times
   */
  public static RegularExpression repeatExactly(RegularExpression g, int amount) {
    return new RegularExpression(g, g.selfAsGrouped(),
        "{", Integer.toString(amount), "}");
  }

  /**
   * Returns a regex which matches any string that consists of the given string repeated at least min times
   *
   * @param s   the string to repeat
   * @param min the minimum number of times the character should repeat (inclusive)
   * @return a regex which matches any string that consists of the given string repeated at least min times
   */
  public static RegularExpression repeatAtLeast(String s, int min) {
    return repeatAtLeast(s, min, EvaluationMethod.GREEDILY);
  }

  /**
   * Returns a regex which matches any string that consists of any string the given regex matches repeated at least min times
   *
   * @param g   the regex to repeat
   * @param min the minimum number of times the regex should repeat (inclusive)
   * @return a regex which matches any string that consists of any string the given regex matches repeated at least min times
   */
  public static RegularExpression repeatAtLeast (RegularExpression g, int min) {
    return repeatAtLeast(g, min, EvaluationMethod.GREEDILY);
  }

  /**
   * Returns a regex which matches any string that consists of the given string repeated at least min times
   * This uses the provide Evaluation method
   *
   * @param s   the string to repeat
   * @param min the minimum number of times the character should repeat (inclusive)
   * @param t   the evaluation type
   * @return a regex which matches any string that consists of the given string repeated at least min times
   */
  public static RegularExpression repeatAtLeast(String s, int min, EvaluationMethod t) {
    if (s.length() == 1) {
      return new RegularExpression(sanitized(s.charAt(0)),
          "{", Integer.toString(min), ",}", t.toRegex());
    } else {
      return new RegularExpression(
          "(?:", sanitized(s), ")",
          "{", Integer.toString(min), ",}", t.toRegex());
    }
  }

  /**
   * Returns a regex which matches any string that consists of any string the given regex matches repeated at least min times
   * This uses the provide Evaluation method
   *
   * @param g   the regex to repeat
   * @param min the minimum number of times the regex should repeat (inclusive)
   * @param t   the evaluation type
   * @return a regex which matches any string that consists of any string the given regex matches repeated at least min times
   */
  public static RegularExpression repeatAtLeast (RegularExpression g, int min, EvaluationMethod t) {
    return new RegularExpression(g, g.selfAsGrouped(),
        "{", Integer.toString(min), ",}", t.toRegex());
  }

  /**
   * Returns a regex which matches any string that consists of the given string repeated at most max times
   *
   * @param s   the string to repeat
   * @param max the maximum number of times the character should repeat (inclusive)
   * @return a regex which matches any string that consists of the given string repeated at most max times
   */
  public static RegularExpression repeatAtMost(String s, int max) {
    return repeatAtMost(s, max, EvaluationMethod.GREEDILY);
  }

  /**
   * Returns a regex which matches any string that consists of any string the given regex matches repeated at most max times
   *
   * @param g   the regex to repeat
   * @param max the maximum number of times the regex should repeat (inclusive)
   * @return a regex which matches any string that consists of any string the given regex matches repeated at most max times
   */
  public static RegularExpression repeatAtMost (RegularExpression g, int max) {
    return repeatAtMost(g, max, EvaluationMethod.GREEDILY);
  }

  /**
   * Returns a regex which matches any string that consists of the given string repeated at most max times
   * This uses the provide Evaluation method
   *
   * @param s   the string to repeat
   * @param max the maximum number of times the character should repeat (inclusive)
   * @param t   the evaluation type
   * @return a regex which matches any string that consists of the given string repeated at most max times
   */
  public static RegularExpression repeatAtMost(String s, int max, EvaluationMethod t) {
    if (s.length() == 1) {
      return new RegularExpression(sanitized(s.charAt(0)),
          "{0,", Integer.toString(max), "}", t.toRegex());
    } else {
      return new RegularExpression(
          "(?:", sanitized(s), ")",
          "{0,", Integer.toString(max), "}", t.toRegex());
    }
  }

  /**
   * Returns a regex which matches any string that consists of any string the given regex matches repeated at most max times
   * This uses the provide Evaluation method
   *
   * @param g   the regex to repeat
   * @param max the maximum number of times the regex should repeat (inclusive)
   * @param t   the evaluation type
   * @return a regex which matches any string that consists of any string the given regex matches repeated at most max times
   */
  public static RegularExpression repeatAtMost (RegularExpression g, int max, EvaluationMethod t) {
    return new RegularExpression(g, g.selfAsGrouped(),
        "{0,", Integer.toString(max), "}", t.toRegex());
  }

  /*
   *********************
   * Logical Operators *
   *********************
   */

  /**
   * Constructs a regular expression from the given sub-components. The
   * new RegularExpression constructed will be the concatenation of all of the subcomponents.
   * <p>
   * In other words, if the subcomponents match "a", "b" and "c", then the new regular
   * expression will match "abc"
   *
   * @param components the sub-components of the regular expression
   * @return a new regular expression matching the concatenation of the arguments
   */
  public static RegularExpression concatenate (RegularExpression... components) {
    return new RegularExpression(components);
  }

  /**
   * Returns a regex which matches one of the given regular expressions. If no regular expressions
   * are provided in the arguments, a regular expression matching nothing is returned
   *
   * @param rs the regular expressions that are the options
   * @return a regex which matches one of the given regular expressions
   */
  public static RegularExpression oneOf(RegularExpression... rs) {
    if (rs.length > 1) {
      RegularExpression regex = new RegularExpression("");
      StringBuilder b = new StringBuilder();
      b.append("(?:");
      regex.appendRegex(b, rs[0]);
      for (int i = 1; i < rs.length; i++) {
        b.append("|");
        regex.appendRegex(b, rs[i]);
      }
      b.append(")");
      regex.rawRegex = b.toString();
      return regex;
    } else if (rs.length == 1) {
      return rs[0];
    } else {
      return new RegularExpression("");
    }
  }

  /*
   *******************
   * Back-References *
   *******************
   */

  /**
   * Returns a new regex that matches the same thing that the i^th capturing group within a larger regex matched.
   * <p>
   * See Capturing Groups in the class-level documentation
   *
   * @param i Which capturing group to match on
   * @return a regex that matches the same thing that the i^th capturing group within a larger regex matched.
   */
  public static RegularExpression backReference(int i) {
    return new RegularExpression("\\", Integer.toString(i));
  }

  /**
   * Returns a new regex that matches the last thing that the capturing group passed in matched.
   *
   * @param group Which capturing group to match on
   * @return a regex that matches the same thing that the last instance of group matched.
   */
  public static RegularExpression backReference(CapturingGroup group) {
    return new RegularExpression("\\k", group.label);
  }

  /*
   **************
   * Lookaround *
   **************
   */

  /**
   * Returns a new regex that matches any string that the given regex matches, without consuming any characters.
   * The returned regex essentially acts as an "assert" that the rest of the string matches.
   * <p>
   * In technical terms, the new regex performs zero-width positive lookahead on the provided regex
   *
   * @param r the regex to perform lookahead on
   * @return a new regex that asserts that the rest of the string matches r, but does not consume any characters
   */
  public static RegularExpression lookahead(RegularExpression r) {
    return new RegularExpression(r,
        "(?=",
        r.rawRegex,
        ")"
    );
  }

  /**
   * Returns a new regex that matches any string that the given regex does not match, without consuming any characters.
   * The returned regex essentially acts as an "assert" that the rest of the string does not match.
   * <p>
   * In technical terms, the new regex performs zero-width negative lookahead on the provided regex
   *
   * @param r the regex to perform negative lookahead on
   * @return a new regex that asserts that the rest of the string does not match r, but does not consume any characters
   */
  public static RegularExpression negativeLookahead(RegularExpression r) {
    return new RegularExpression(r,
        "(?!",
        r.rawRegex,
        ")"
    );
  }

  /**
   * Returns a new regex that asserts that the preceding part of the string (within a larger regex) matches the provided
   * regex <code>r</code>, without consuming any characters.
   * The returned regex essentially acts as an "assert" that the previous part of the string matches.
   * <p>
   * In technical terms, the new regex performs zero-width positive lookbehind on the provided regex
   *
   * @param r the regex to perform lookbehind on
   * @return a new regex that asserts that the preceding part of the string matches r, but does not consume any characters
   */
  public static RegularExpression lookbehind(RegularExpression r) {
    return new RegularExpression(r,
        "(?<=",
        r.rawRegex,
        ")"
    );
  }

  /**
   * Returns a new regex that asserts that the preceding part of the string (within a larger regex) does not match the
   * provided regex <code>r</code>, without consuming any characters.
   * The returned regex essentially acts as an "assert" that the previous part of the string does not match.
   * <p>
   * In technical terms, the new regex performs zero-width negative lookbehind on the provided regex
   *
   * @param r the regex to perform negative lookbehind on
   * @return a new regex that asserts that the preceding part of the string does not match r, but does not consume any characters
   */
  public static RegularExpression negativeLookbehind(RegularExpression r) {
    return new RegularExpression(r,
        "(?<!",
        r.rawRegex,
        ")"
    );
  }

}
